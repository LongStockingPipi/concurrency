死锁

发生在并发中，互不相让。

死锁在不同的系统中影响是不同的，这取决于系统对死锁的处理能力：
    数据库中：检测并放弃事务；
    JVM：无法自动处理，死锁的发生几率不高，但是危害极大，且压力测试无法找出潜在的死锁；

发生死锁的四个必要条件：
    1. 互斥条件：资源不共享，同一时间只能有一个线程持有；
    2. 请求于保持条件：请求其他资源的同时不释放已经获取的资源；
    3. 不剥夺条件：不会有其他因素强制剥夺已持有的资源（数据库利用这点解决死锁）；
    4. 循环等待：请求方向形成环路；

 检测死锁：
    1. 使用命令行jstack
    2. 使用工具类ThreadMXBean

避免死锁的方法：
    1. 设置超时时间：Lock的tryLock方法可以设置，synchronized本身不具备尝试获取锁的机制；
    2. 多使用并发类，多使用并发集合少使用同步集合；
    3. 降低锁的使用粒度，用不同的锁而不是同一把锁；
    4. 避免锁的嵌套；
    5. 专锁专用；

哲学家就餐问题的解决方法：
1. 改变一个人的获取餐具的顺序，与改变锁的获取顺序同理（可以根绝锁的哈希值大小判断应该先获取哪一个锁，可以解决转账问题）
2. 检测锁的调用环路图，发现死锁后可以采取以下策略：
    进程终止：终止顺序可以参考：优先级、已经占用资源还需要的资源、已经运行时间
    资源抢占：线程回退，但是可能出现饥饿状态

活跃性问题：
1. 活锁
活锁是常见的活跃性问题
活锁特点：线程没有阻塞，一直在运行；但是程序得不到进展，因为线程始终在做同样的事。

2. 饥饿
线程需要的资源（通常指cpu资源）一直得不到。例如线程的优先级太低一直得不到运行、某线程持有锁同时又无限循环从而不释放锁。
导致响应性差


死锁常见面试题：
1. 死锁发生需要哪些条件？
    （死锁的四个必要条件）
2. 如何定位死锁？
    jstack、ThreadMXBean工具类
3. 有哪些解决死锁的策略？
    避免策略：哲学家就餐换手、转账换序
    检测与恢复：
4. 如何避免死锁？
5. 什么是活跃性问题？活锁、饥饿和死锁有什么区别？