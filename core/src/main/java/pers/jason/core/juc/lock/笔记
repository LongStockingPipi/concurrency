为什么synchronized不够用？
    1. 效率低，释放锁的情况少，试图获取锁的时候不能设置超时时间，不能中断一个试图获取锁的线程；
    2. 不够灵活，加锁和释放锁单一，每个锁仅有单一条件（某个对象）；
    3. 无法知道是否成功获取锁；

Lock接口重要方法：
    1. 获取锁：
        1.1. lock()
            最普通的获取锁，如果锁已经被其他线程占用，则等待；
            注意：
                1) Lock锁不会像synchronized一样异常自动释放锁，需要我们手动的去释放，因此尽量使用try、catch、finally格式释放锁；
                2) lock()方法不会被中断，一旦陷入死锁，则永久等待；
        1.2. tryLock()
            尝试获取锁，如果锁没有被其他线程占用，则获取成功，返回true，否则返回false；该方法会立刻返回，即便没有拿到锁也不会一直等待；
        1.3. tryLock(long time, TimeUnit unit)
            相对于tryLock()，该方法设置超时时间，如果规定时间内拿到锁则返回true，一旦超时还没有拿到锁则返回false；
        1.4. lockInterruptibly()
            作用相当于tryLock(long time, TimeUnit unit)的时候超时时间设置成无限，但是，lockInterruptibly()具有等待过程中可以被中断的功能；
    2. 释放锁：
        unLock()：应该写在finally代码块中

可见性保证
    Lock锁与Synchronized一样拥有可见性原则

锁的分类
    线程是否锁住资源：
        1. 悲观锁（互斥同步锁）：锁住资源
        2. 乐观锁（非互斥同步锁）：不锁住资源
        -互斥同步锁的劣势：阻塞、唤醒带来的性能问题，死锁、永久循环带来的永久阻塞问题，优先级反转；典型的悲观锁就是Synchronized和Lock相关类；
        -乐观锁任务自己处理的时候不会有其他线程干扰，因此不会锁住对象；在更新的时候，会对比我修改期间数据有没有被其他人改过，如果没有改过，则说明真的只有
        我自己在操作，那就正常修改数据；如果有改过，则放弃修改，可以选择放弃、报错、重试等；乐观锁的实现一般采用CAS算法；
        原子整型就是典型的乐观锁，遗迹git版本管理也是使用乐观锁；

        对比：
        悲观锁的开销要大于乐观锁，但是一劳永逸，乐观锁开始开销小，但是如果线程自旋或不停重试，则开销越来越大；
        悲观锁适用于并发写很多，或持有锁时间很长的情况，避免大量的无用的自旋消耗；典型情况：临界区有IO操作、临界区代码复杂，循环大、临界区竞争激烈；
        乐观锁适用于并发写少，大部分是读场景，不加锁能让读的性能大幅度提高；
    多个线程能否共享一把锁：
        1. 共享锁：可以共享
        2. 排他锁：不可以共享
        排他锁又称独占锁、独享锁；共享锁又称读锁，获得共享锁之后，多个线程可以同时获得该锁，但是无法修改和删除数据；
        共享锁和排他锁的典型就是读写锁ReentrantReadWriteLock，其中读锁是共享锁，写锁是排他锁；
        读写锁的规则：
            多个线程同时申请读锁，都可以申请到；
            如果读锁已经被某些线程占用，此时无法获取写锁，知道读锁被释放；
            如果写锁被某个线程占用，此时读锁、写锁都无法被获取到；
        读锁插队策略：
            1. 线程1、线程2已经获得读锁，线程3申请写锁并等待，此时，线程4申请读锁可以立即获得；
                该策略可以显著提高读效率，但是容易造成写线程饥饿；
            2. 线程1、线程2已经获得读锁，线程3申请写锁并等待，此时线程4申请读锁必须排到线程3后面等待；即队列头如果是写锁，则不插队，如果不是，则插队；
                避免写线程饥饿
        ReentrantReadWriteLock支持锁的降级，不支持锁的升级；写锁在写操作完成之后，可以选择降级为读锁来让其他读线程共享资源；
        其他读写锁有的可以支持升级，但是必须保证同一时间只有一个读锁升级，因为读锁升级为写锁的前提是其他读线程放弃读锁，而如果存在两个或两个以上的线程
        同时想升级，互相等待对方放弃读锁，会造成死锁的情况；
    多线程竞争时，是否排队：
        1. 公平锁：排队
        2. 非公平锁：不排队
        公平指的是按照线程请求的顺序来分配锁；非公平指的是不完全按照线程请求顺序分配锁；
        注意：即使是非公平，也不提倡插队，只是在合适的时机插队；
        线程从阻塞到唤醒是需要时间的，而非公平锁的优点就是避免浪费了线程唤醒带来的空档期；
        ReentrantLock构造方法参数可以设置是否公平，true为公平锁，false为非公平所，默认为true；但是，tryLock()方法特殊，即使Lock设定为公平锁，tryLock()
        依然不遵守公平原则，只要该时刻其他线程依然处于阻塞状态，它就可以立即获取锁；
        对比：
            公平锁各个线程公平，每个线程等待一段时间后总会执行，但是效率低，吞吐量小；
            非公平所吞吐量更大，但是可能产生线程饥饿，某些线程长时间得不到执行；
    同一个线程是否可以重复获取同一把锁：
        1. 可重入锁：可以
        2. 不可重入锁：不可以
        可重入指的是同一个线程可以多次获取同一把锁，Synchronized和ReentrantLock都是可重入锁；
    是否可中断：
        1. 可中断锁：可以
        2. 不可中断锁：不可以
        Synchronized是不可中断锁，而Lock则是可中断锁；
        可中断锁值得是在获取锁的时候，如果没有获取到锁并等待，在等待过程中可以相应中断而停止等待过程则成为可中断锁；
    等锁过程：
        1. 自旋锁：自旋
        2. 非自旋锁：阻塞
        自旋锁：线程如果申请不到锁资源，不会放弃CPU的执行时间，线程处于自旋状态，等待前一个线程释放锁；通常用于同步代码执行时间较少的情况下；
            很多源自类内部使用自旋锁，使用do while循环直到修改成功
            使用场景：多和服务器，并发度不高；比阻塞锁效率高；临界区比较短小；
            缺点：如果锁的占用时间过长，自旋可能会白浪费处理器资源；
        阻塞锁：如果没有申请到锁，则直接把线程阻塞，直到被唤醒；
        自旋锁和自适应能力属于虚拟机的一种优化；