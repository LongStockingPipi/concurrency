为什么synchronized不够用？
    1. 效率低，释放锁的情况少，试图获取锁的时候不能设置超时时间，不能中断一个试图获取锁的线程；
    2. 不够灵活，加锁和释放锁单一，每个锁仅有单一条件（某个对象）；
    3. 无法知道是否成功获取锁；

Lock接口重要方法：
    1. 获取锁：
        1.1. lock()
            最普通的获取锁，如果锁已经被其他线程占用，则等待；
            注意：
                1) Lock锁不会像synchronized一样异常自动释放锁，需要我们手动的去释放，因此尽量使用try、catch、finally格式释放锁；
                2) lock()方法不会被中断，一旦陷入死锁，则永久等待；
        1.2. tryLock()
            尝试获取锁，如果锁没有被其他线程占用，则获取成功，返回true，否则返回false；该方法会立刻返回，即便没有拿到锁也不会一直等待；
        1.3. tryLock(long time, TimeUnit unit)
            相对于tryLock()，该方法设置超时时间，如果规定时间内拿到锁则返回true，一旦超时还没有拿到锁则返回false；
        1.4. lockInterruptibly()
            作用相当于tryLock(long time, TimeUnit unit)的时候超时时间设置成无限，但是，lockInterruptibly()具有等待过程中可以被中断的功能；
    2. 释放锁：
        unLock()：应该写在finally代码块中

可见性保证
    Lock锁与Synchronized一样拥有可见性原则

锁的分类
    线程是否锁住资源：
        1. 悲观锁（互斥同步锁）：锁住资源
        2. 乐观锁（非互斥同步锁）：不锁住资源
        -互斥同步锁的劣势：阻塞、唤醒带来的性能问题，死锁、永久循环带来的永久阻塞问题，优先级反转；典型的悲观锁就是Synchronized和Lock相关类；
        -乐观锁任务自己处理的时候不会有其他线程干扰，因此不会锁住对象；在更新的时候，会对比我修改期间数据有没有被其他人改过，如果没有改过，则说明真的只有
        我自己在操作，那就正常修改数据；如果有改过，则放弃修改，可以选择放弃、报错、重试等；乐观锁的实现一般采用CAS算法；
        原子整型就是典型的乐观锁，遗迹git版本管理也是使用乐观锁；

        对比：
        悲观锁的开销要大于乐观锁，但是一劳永逸，乐观锁开始开销小，但是如果线程自旋或不停重试，则开销越来越大；
        悲观锁适用于并发写很多，或持有锁时间很长的情况，避免大量的无用的自旋消耗；典型情况：临界区有IO操作、临界区代码复杂，循环大、临界区竞争激烈；
        乐观锁适用于并发写少，大部分是读场景，不加锁能让读的性能大幅度提高；
    多个线程能否共享一把锁：
        1. 共享锁：可以共享
        2. 独占锁：不可以共享
    多线程竞争时，是否排队：
        1. 公平锁：排队
        2. 非公平锁：不排队
    同一个线程是否可以重复获取同一把锁：
        1. 可重入锁：可以
        2. 不可重入锁：不可以
        可重入指的是同一个线程可以多次获取同一把锁，Synchronized和ReentrantLock都是可重入锁；
    是否可中断：
        1. 可中断锁：可以
        2. 不可中断锁：不可以
    等锁过程：
        1. 自旋锁：自旋
        2. 非自旋锁：阻塞