synchronized用法分类：
1. 对象锁：
    1.1. 同步代码块
    1.2. 同步方法（锁定this）
2. 类锁
    2.1. synchronized(*.class)代码块
    2.2. synchronized加在static方法上（静态方法锁）
    概念：类的实例可能有多个，但是类对象只有一个。而类锁本质就是类对象的锁。类锁在同一时间只能被一个对象所拥有。


六个问题：
1. 两个线程同时访问一个对象的非静态同步方法
    非静态同步方法本质是对象锁（this），由于是同一个对象，因此会正常执行；
2. 两个线程同时访问两个对象的非静态同步方法
    两个线程锁的是各自不同的实例，不能正常执行；
3. 两个线程方法的是静态同步方法
    静态同步方法本质是类锁，类对象只有一个，因此可以正常执行；
4. 访问同一个对象的不同的非静态同步方法
    非静态同步方法本质是对象锁，由于方法同一个对象，两个线程依然是顺序执行；
5. 访问同一个对象的静态同步方法和非静态同步方法
    对象锁个类锁不是同一个锁，因此两个线程会并行执行；
6. synchronized代码中抛出异常后会主动释放锁


synchronized的特性：
1. 可重入：同一个线程的外层函数获得锁之后，内层函数可以直接再次获得该锁；
    好处：避免死锁，提成封装性；
    粒度：线程范围，只要需要的依然是这把锁，就无需释放再申请；
2. 不可中断：：一旦锁已经被其他线程占有，该线程只能等待或者阻塞，知道其他线程释放这个锁。如果一直不释放，则一直等待下去；
    可中断性：如Lock类，拥有可中断性，如果等待时间过长，可以主动中断占用锁的线程；或者可以选择退出；


synchronized原理：
1. 加锁、释放锁原理
    每一个对象都与一个Monitor关联，而Monitor的lock锁只能在同一时间被一个线程获得，线程获得Monitor锁的时候（字节码执行monitor enter），Monitor计数器+1，
    释放monitor锁的时候（字节码执行Monitor exit）Monitor计数器-1，当计数器为0的时候，表示没有线程占用锁；
2. 可重入原理
    加锁次数计数器累加
3. 可见性原理
    每个线程都拥有自己的本地内存，本地内存有主内存共享变量的副本，每次退出synchronized代码快后，都会主动的将本地内存中的数据写入主内存中，作为更新；


synchronized缺陷：
    1. 效率低：
        锁的释放情况少：只能代码执行完成或抛出异常
        试图获取锁的时候不能设置超时时间
        不能中断一个试图获得锁的线程
    2. 不够灵活：
        锁的获取和释放时机单一，仅能以对象（包括类对象）作为加锁条件（对比读写锁）
    3. 无法知道是否成功获取锁


常见面试题：
    1. 使用synchronized注意的事项
        1.1. 锁对象不能为空
        1.2. 作用域不宜过大
        1.3. 避免死锁
    2. 如何选择Lock和synchronized？
        2.1. 如果适用synchronized，则使用，synchronized代码较少，减少出错；
    3. 多个线程等待同一个锁，JVM如何选择下一个获取锁的线程？
        不可控，依赖JVM版本的具体实现；
    4. 什么是锁的升级、降级？什么是JVM的偏斜锁、轻量级锁、重量级锁？

